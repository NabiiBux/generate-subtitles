script.
  const progressUpload = (evt, startDate, uploadStarted, circleProgress, fileName) => {
    l(evt);
    $('#form').hide();
    $('#startNewUpload').show();

    const uploadedAmountInMB = _.round(evt.loaded / (1024 * 1024), 1);
    const totalFileSizeInMB = _.round(evt.total / (1024 * 1024), 1);
    const percentUpload = Math.round((uploadedAmountInMB / totalFileSizeInMB) * 100);
    // get time in seconds between upload start time and now
    const timeElapsedInSeconds = Math.round((new Date() - startDate) / 1000);
    // estimate how many seconds remaining based on percentage
    const estUploadTimeInSeconds = Math.round(timeElapsedInSeconds * (100 / percentUpload));
    // time left is difference of estimated time and elapsed time
    const estSecondsRemaining = estUploadTimeInSeconds - timeElapsedInSeconds;

    l({percentUpload});
    l({timeElapsedInSeconds});
    l({estSecondsRemaining});

    $('#progress').html(`${percentUpload}% uploaded`);
    document.title = `${percentUpload}% Uploaded - ${fileName}`;

    circleProgress.attr({
      max: 100,
      value: Number(percentUpload),
    });

    if (percentUpload === 100) {
      circleProgress.attr({
        max: 100,
        value: 0,
      });
      $('.progress').hide();
    } else {
      $('.progress').show();
    }

    // start up functionality to update estimate every second
    if (!uploadStarted) {
      uploadStarted = true;
      setInterval(() => {
        const estSecondsIsInfinity = estSecondsRemaining === Infinity;
        const estSecondsIsNan = isNaN(estSecondsRemaining);
        const uploadSpeedInMBs = _.round((uploadedAmountInMB / timeElapsedInSeconds), 1);

        const valueIsValid = !estSecondsIsInfinity && !estSecondsIsNan;
        if (!valueIsValid) return;

        $('#timeEstimator').html(`[${timeElapsedInSeconds}/${estUploadTimeInSeconds}s] ${forHumans(estSecondsRemaining)} remaining
          \n Total File Size: ${totalFileSizeInMB} MB, \nAlready Uploaded: ${uploadedAmountInMB} MB \nUpload Speed: ${uploadSpeedInMBs} MB/s,
          `);
      }, 1000)
    }
  }

  const loadAjax = res => {
    l({res});
    $('#processingData').show();
    $('#latestData').show();
    $('#progress').hide();
    $('#timeEstimator').hide();
    $('#header').html('Processing..');
  }

  const renderQueue = place => {
    $('#latestData').html(place === 0 ? `Starting now...` : place === 1 ? `You're next up` : `There are ${place} people ahead of you.`);
  }

  const renderCompletionFeedback = data => {
    $('#latestData').html(`Congratulations, you're done!`);
    $('#finishedData').html(data.detailsString);
    $('#header').html('Transcription Completed');
    $('#processingData').hide();
    // show refresh button
    $('#refreshButton').show();
    $('#startNewUpload').hide();
  }

  const renderProcessingFeedback = ({data, hitTheBackend}) => {
    l('websocket data');
    let loopStarted, myUploadStarted = false;
    //- destructure the data object -osb910
    let {
      ownershipPerson,
      serverNumber: processNumber,
      percentDone,
      timeRemaining,
      processingData,
      formattedProgress
    } = data;
    const myUpload = ownershipPerson === 'you';

    // disregard any data that isn't yours after your processing has started
    if (!myUpload && myUploadStarted) return;

    const fileName = $('#file').prop('files')[0].name;
    if (percentDone) {
      document.title = `${percentDone}% Transcribed - ${fileName}`;
    }

    // by default let to 'latest processing'
    // TODO: this is misnamed, it's not the upload that's started but the processing
    let processFeedback = `Latest processing data (process ${processNumber})\n`;
    if (myUpload) {
      /** it's your upload **/
      // data is no longer relevant
      $('#secondProcessingData').hide();
      myUploadStarted = true; // force this to true
      processFeedback = ``;
      $('#latestData').hide();
    }

    // TODO: what does this eitherProcess check actually accomplish?
    // every second it grabs it from the ether and decrements it and rebuilds the string
    const eitherProcess = processNumber ===  1 || processNumber === 2;
    l({eitherProcess});

    const myUploadProcessing = myUpload && hitTheBackend && myUploadStarted

    // TODO: need my upload finished? && !myUploadFinished
    l({eitherProcess, myUpload, hitTheBackend, myUploadStarted});
    if (eitherProcess && myUploadProcessing) {
      l('found my data');
      $('#processingData').show();
      // actual process data coming back
      if (percentDone > 0) {
        circleProgress.attr({
          max: 100,
          value: percentDone,
        });

        if (percentDone === 100) {
          $('.progress').hide();
        } else {
          $('.progress').show();
        }

        if (!loopStarted) {
          loopStarted = true;

          if (!window.decrementInterval) {
            // BUG: timer reaches 0 early because it's out of sync with the actual progress, maybe calculate it on the backend? -osb910
            window.decrementInterval = setInterval(() => {
              timeRemaining = decrementBySecond(timeRemaining);
              l({timeRemaining});

              const progressUpdate = `[${formattedProgress.percentDone}] ${timeRemaining.string} Remaining, Speed ${formattedProgress.speed}f/s`;

              $('#processingData').html(`${processFeedback}${progressUpdate}`);
            }, 1000);
          }
        }
      } else {
        $('#processingData').html(`${processFeedback}Transcription starting soon..`);
      }
    }

    // TODO: this seems off
    // update the process 2 info if appropriate
    if (!myUpload && !myUploadStarted && hitTheBackend) {
      l(`getting process ${processNumber} data`);
      $(`${processNumber === 1 ? '#processingData' : '#secondProcessingData'}`).show();
      $(`${processNumber === 1 ? '#processingData' : '#secondProcessingData'}`).html(`${processFeedback}\n${data.processingData}`);
    }
  }