include js-util.jade
include controllers/selection-dropdowns.jade
script.
  l = console.log;

  // global variables
  let processStarted, processFailed, myUploadStarted, uploadFinished = false;
  let circleProgress, fileName, hitTheBackend;

  // passed from server
  const languagesArray = !{JSON.stringify(languagesArray)}
  const modelsArray = !{JSON.stringify(modelsArray)}
  const isFreeSubtitles = #{isFreeSubtitles}
  const uploadFileSizeLimitInMB = #{uploadFileSizeLimitInMB}
  const nodeEnvironment = `#{nodeEnv}`

  // grab elements
  const form = $('#form');
  const progressDiv = $('#progress');
  const timeRemainingDiv = $('#timeEstimator');
  const header = $('#header')
  const refreshButton = $('#refreshButton');
  const latestData = $('#latestData');
  const file = $("#file");
  const body = document.querySelector('body');
  const languageOptions = Array.from(document.querySelectorAll('.options.languages .option'));
  const modelOptions = Array.from(document.querySelectorAll('.options.models .option'));

  // local storage
  const previousModel = localStorage.getItem('model');
  const previousModelName = localStorage.getItem('modelName');
  const previousLanguage = localStorage.getItem('language');
  const previousLanguageName = localStorage.getItem('languageName');
  const previousShouldTranslate = localStorage.getItem('shouldTranslate');

  $(document).ready(() => {
    circleProgress = new CircleProgress('.progress', {
      max: 100,
      value: 100,
      textFormat: 'vertical',
    });

    l('ready now');
  });


  const getVideoDuration = file =>
    new Promise((resolve, reject) => {
      const reader = new FileReader();
      l(file);
      l(reader);
      reader.onload = e => {
        l({e});
        l('loading');
        l(reader);
        const media = new Audio(reader.result);
        l(media);
        media.onerror = function(error){
          l({error});
          reject(error);
        }
        media.onloadedmetadata = () => resolve(media.duration);
      };
      l('reading')
      reader.readAsDataURL(file);
      reader.onerror = function(error){
        l({error})
        reject(error);
      }
    });

  // had to do this because of the greater than thing (remove backslash)
  // otherwise could do const forHumans = #/{forHumans}
  eval(unescapeHTML(`#{forHumans}`));

  // l(forHumans(100));


  //-  Add selected class to both selected options
  const selectedLang = languageOptions.find(opt => opt.dataset.value === previousLanguage) || languageOptions[0];
  const selectedModel = modelOptions.find(opt => opt.dataset.value === previousModel) || modelOptions.find(opt => opt.dataset.value === 'medium');
  l({selectedModel})

  selectedLang.classList.add('selected');
  selectedModel.classList.add('selected');
  
  //- Populate previous values from local storage
  //- jquery doesn't work here for some reason, strange bug
  //- $('#model').data('value', (previousModel || 'medium'));
  //- $('#language').data('value', (previousLanguage || 'auto-detect'));
  document.querySelector('#model').dataset.value = previousModel || 'medium';
  document.querySelector('#language').dataset.value = previousLanguage || 'auto-detect';

  $('#model').text(previousModelName || 'Medium');
  $('#language').text(previousLanguageName || 'Auto-Detect');

  $('#translate').prop('checked', previousShouldTranslate === 'true');

  const ipAndPort = location.host;
  const randomNumber = Math.round(Math.random() * 1_000_000_000_000);

  // Handle clicks with event delegation
  $('body').on('click', evt => {
    const clicked = evt.target;
    const selectWrappers = document.querySelectorAll('#form .wrapper');
    const selectionBtn = clicked.closest('.select-btn');
    const option = clicked.closest('.option');
    const groupElement = clicked.closest('.form .group');
    
    const langSelectionBtn = clicked.closest('.select-btn#languageSelect');
    langSelectionBtn && selectWrappers[1].classList.remove('active');

    selectionBtn && handleSelectionButtonClick(evt); // On selection button click

    option && handleOptionClick(evt); // On option click

    !groupElement && selectWrappers.forEach(wrapper => wrapper.classList.remove('active')); // On outside form group click
  });

  // handle input with event delegation
  $('body').on('input', evt => {
    // Elements
    const pressed = evt.target;
    const selectWrapper = pressed.closest('form .wrapper');
    selectWrapper && handleSelectionInput(evt);
  });

  // handle key press with event delegation
  $('body').on('keydown', evt => {
    const pressed = evt.target;
    const selectionContent = pressed.closest('form .content');

    selectionContent && handleSelectionShortcuts(evt);
  });


  form.on('submit', submitForm);

  let uploadStarted = false;
  const selectElement = document.querySelector('#file');

  let videoDurationInSeconds;

  // freezes everything up
  // selectElement.addEventListener('change', async function () {
  //   l('getting video duration!');
  //   // l(new Date())
  //   // videoDuration = getVideoDuration(file.files[0]).then(function(response){
  //   //   videoDuration = response;
  //   //   l(new Date())
  //   //   l('videoDuration');
  //   //   l(videoDuration);
  //   //
  //   // });
  // });

  async function submitForm(e) {
    e.preventDefault();

    const languageEl = document.querySelector('#language');
    const modelEl = document.querySelector('#model');

    let language = languageEl.dataset.value;
    let languageName = languageEl.textContent;
    const model = modelEl.dataset.value;
    const modelName = modelEl.textContent;

    const formData = new FormData();

    const passedFile = file.prop('files')[0];

    if(!passedFile){
      return Swal.fire({
        title: 'You didn\'t pass a file',
        icon: 'error',
        confirmButtonText: 'Cool'
      })
    }

    // http or https
    const protocol = document.location.protocol.slice(0, -1);
    const servedWithSSL = protocol === 'https';

    l({passedFile});

    if(nodeEnvironment === 'production' && isFreeSubtitles){

    // force upload testing
    // if(1 === 1){
      // TODO: change this to onchange
      // TODO: load this from the backend
      const passedFileSizeInMB = Math.round(passedFile.size / 1048576);

      // swal with the error
      if (passedFileSizeInMB > uploadFileSizeLimitInMB) {
        // put back upload button
        $('#upload-button').html('Upload').removeClass('no-pointer-events');

        return Swal.fire({
          title: `Your file size of ${passedFileSizeInMB}MB is too large. The limit is ${uploadFileSizeLimitInMB}MB`,
          icon: 'error',
          confirmButtonText: 'Cool'
        })
      }

      $('#upload-button').addClass('no-pointer-events');

      $('#upload-button').html('Checking your upload length..')

      try {
        l('geting duration');
        // TODO: get here
        // TODO: catch possible errors
        videoDurationInSeconds = await getVideoDuration(passedFile);
        l({videoDurationInSeconds});
      } catch (err){
        /// just let them advance if there's an error, happens with .MOV (format error)
        //  and uploads over 500MB (because of Chrome)
        console.error(err);
      }

      const oneHourInSeconds = 60 * 60;

      // 3600
      // TODO: pass from the backend
      if (videoDurationInSeconds && videoDurationInSeconds > oneHourInSeconds) {
        $('#upload-button').html('Upload').removeClass('no-pointer-events');
        videoDurationInSeconds = 0;
        return Swal.fire({
          title: 'The video is too long',
          text: 'To share time more evenly 1h+ uploads are not allowed currently',
          icon: 'error',
          confirmButtonText: 'Cool'
        })
      }
    }

    const translateIsChecked = $('#translate').is(':checked');

    formData.append('file', passedFile);
    formData.append('language', language);
    formData.append('model', model);
    formData.append('websocketNumber', randomNumber);
    formData.append('shouldTranslate', translateIsChecked);

    localStorage.setItem('model', model);
    localStorage.setItem('modelName', modelName);
    localStorage.setItem('language', language);
    localStorage.setItem('languageName', languageName);
    localStorage.setItem('shouldTranslate', translateIsChecked);

    // Display the key/value pairs
    for (const pair of formData.entries()) {
      console.log(pair[0] + ': ' + pair[1]);
    }
    fileName = $('#file').prop('files')[0].name;
    l({fileName});

    const httpProtocol = window.location.protocol;

    const httpPrepend = httpProtocol === 'https:' ? 'https' : 'http';

    const uploadUrl = `${httpPrepend}://${ipAndPort}/file`;

    const ajax = new XMLHttpRequest();
    let originalDate, timeElapsedInSeconds, estimatedUploadTimeInSeconds, estimatedSecondsRemaining, percentUploadDone;

    $('.amountsHeader').hide();

    window.addEventListener('beforeunload', (event) => {
      if(!uploadFinished && !processFailed){
        // this text doesnt actually show up
        event.returnValue = `You have an ongoing transcription and if you leave you have to start over. Are you sure you want to leave?`;
      }
    });

    let alreadyUploadedAmountInMB;
    /** TIME COUNTDOWN FUNCTIONALITY **/
    ajax.upload.addEventListener("progress", function(event){
      l(event);
      form.hide();
      $('#startNewUpload').show();

      alreadyUploadedAmountInMB = _.round(event.loaded / (1000 * 1000), 1);
      let totalFileSizeInMB = _.round(event.total / (1000 * 1000), 1);

      l('totalFileSizeInMB');
      l(totalFileSizeInMB);

      l('alreadyUploadedAmountInMB');
      l(alreadyUploadedAmountInMB);

      var percent = Math.round((alreadyUploadedAmountInMB / totalFileSizeInMB) * 100);

      percentUploadDone = percent

      progressDiv.html(`${percent}% uploaded`);

      const capitalizedString = `${percent}% Uploaded - ${fileName}`;

      const currentTitle = document.title;
      if(currentTitle !== capitalizedString){
        document.title = capitalizedString;
      }

      const currentTime = new Date();
      // get time in seconds between upload start time and now
      timeElapsedInSeconds = Math.round((currentTime - originalDate) / 1000);

      // estimate how many seconds remaining based on percent
      estimatedUploadTimeInSeconds = Math.round(timeElapsedInSeconds * (100/percent));

      // time left is difference of estimated time and elapsed time
      estimatedSecondsRemaining = estimatedUploadTimeInSeconds - timeElapsedInSeconds;

      l({estimatedSecondsRemaining});
      l({percent});
      l({timeElapsedInSeconds});

      circleProgress.attr({
        max: 100,
        value: Number(percentUploadDone),
      });
      if(percent === 100){
        circleProgress.attr({
          max: 100,
          value: 0,
        });
        $('.progress').hide();
      } else {
        $('.progress').show();
      }


      // start up functionality to update estimate every second
      if(!uploadStarted){
        uploadStarted = true;
        originalDate = new Date();
        setInterval(function(){

          const estimatedSecondsIsInfinity = estimatedSecondsRemaining === Infinity;
          const estimatedSecondsIsNan = isNaN(estimatedSecondsRemaining);


          Math.round(alreadyUploadedAmountInMB / timeElapsedInSeconds * 10) / 10

          const uploadSpeedInMBs = _.round((alreadyUploadedAmountInMB / timeElapsedInSeconds), 1);

          const valueIsValid = !estimatedSecondsIsInfinity && !estimatedSecondsIsNan;
          if(!valueIsValid) return

          timeRemainingDiv.html(`[${timeElapsedInSeconds}/${estimatedUploadTimeInSeconds}s] ${forHumans(estimatedSecondsRemaining)} remaining
            \n Total File Size: ${totalFileSizeInMB} MB, \nAlready Uploaded: ${alreadyUploadedAmountInMB} MB \nUpload Speed: ${uploadSpeedInMBs} MB/s,
            `);
        }, 1000)
      }
    }, false);

    ajax.addEventListener("error", function (error) {
      l('err');
      console.log(error)
    }, false);

    ajax.addEventListener('readystatechange', function (e) {
      if (ajax.readyState === XMLHttpRequest.DONE) {
        if (ajax.status === 200) {
          // Request has completed successfully, do something
        } else {

          processFailed = true;

          return Swal.fire({
            title: 'Transcription failed',
            text: ajax.responseText,
            icon: 'error',
            showCancelButton: true,
            confirmButtonText: 'Try Again',
          }).then((result) => {
            /* Read more about isConfirmed, isDenied below */
            if (result.isConfirmed) {
              window.location.reload();
            }
          })

          l('failed request');
          l(ajax.responseText);
          // Request has failed, do something
        }
      }
    });

    /** response from endpoint? **/
    ajax.addEventListener("load", function(res){
      l('hit the backend!');
      hitTheBackend = true;
      // $('#processingData').show();
      $('#latestData').show();
      console.log(res)
      progressDiv.hide();
      timeRemainingDiv.hide();

      header.html('Processing..');
    }, false);
    // TODO: implement these
    // ajax.addEventListener("event", eventHandler, false);
    // ajax.addEventListener("abort", abortHandler, false);
    ajax.open("POST", uploadUrl); //
    ajax.send(formData);
  }


  let placeInQueue = 0;

  /** WEBSOCKET CONNECTION FUNCTIONALITY BEGINS **/
  const httpProtocol = window.location.protocol;

  const wssPrepend = httpProtocol === 'https:' ? 'wss' : 'ws';

  const websocketConnection = new WebSocket(`${wssPrepend}://${ipAndPort}/${randomNumber}`);

  websocketConnection.onclose = function (event) {
    processFailed = true;

    // dont show popup if websocket closed because finished
    if(uploadFinished) return
    return Swal.fire({
      title: 'Websocket disconnected',
      text: 'Your websocket connection was disconnected, please refresh to start a new upload',
      icon: 'error',
      showCancelButton: true,
      confirmButtonText: 'Refresh now',
    }).then((result) => {
      /* Read more about isConfirmed, isDenied below */
      if (result.isConfirmed) {
        window.location.reload();
      }
    })

  };

  let loopStarted, processingData, timeRemaining, formattedProgressData = false;

  websocketConnection.onmessage = function (event) {
    const data = JSON.parse(event.data);

    console.log(event.data);

    /** WHEN WEBSOCKET SAYS COMPLETED **/
    // TODO: move to bottom of conditional blocks
    if (data.status === 'Completed') {
      // the upload isn't finished but rather the process
      uploadFinished = true;


      if(window.decrementInterval) clearInterval(window.decrementInterval)

      latestData.html('Congratulations, you\'re done!');

      $('#finishedData').html(data.detailsString);

      header.html('Transcription Completed');
      $('#processingData').hide();

      // show refresh button
      refreshButton.show();

      // TODO: add two more download buttons

      l(data.url)

      $('#startNewUpload').hide();

      websocketConnection.close()

      setTimeout(function(){
        window.location.href = `/player/${data.filename}`
      }, 2000)

    } else if (data.message === 'queue'){
      // TODO: pull out into func
      placeInQueue = data.placeInQueue;
      if (placeInQueue === 1) {
        latestData.html(`You're next up`);
      } else if(placeInQueue > 1){
        latestData.html(`There are ${placeInQueue} people ahead of you`);
      }

      if(placeInQueue === 0){
        latestData.html(`Starting now...`);
      }

      // TODO: likely a bug here
    } else if (data === 'finishedProcessing' && uploadStarted) {
      // placeInQueue = data.placeInQueue;
      placeInQueue = placeInQueue - 1
      // TODO: hate how this is duped, so annoying
      if (placeInQueue === 1) {
        latestData.html(`You're next up`);
      } else if(placeInQueue > 1){
        latestData.html(`There are ${placeInQueue} people ahead of you`);
      }

      if (placeInQueue === 0) {
        latestData.html(`Starting now...`);
      }

    // WEBSOCKET DATA COMING FROM THE BACKEND
    } else if (data.message === 'websocketData') {
      l({data});
      const myUpload = data.ownershipPerson === 'you';
      l({myUpload});

      // disregard any data that isn't yours after your processing has started
      if(!myUpload && myUploadStarted) return

      const processNumber = data.serverNumber; // 1 || 2, really means process
      const percentDone = data.percentDone;
      if(myUpload){
        timeRemaining = data.timeRemaining;
      }
      processingData = data.processingData;
      formattedProgressData = data.formattedProgress;

      const processingString = `${percentDone}% Transcribed - ${fileName}`;

      const currentTitle = document.title;

      if(percentDone && currentTitle !== processingString){
        document.title = processingString;
      }

      // by default let to 'latest processing'
      // TODO: this is misnamed
      let textToSay = `Latest processing data (process ${processNumber})\n`;
      if(myUpload){
        /** it's your upload **/
        // data is no longer relevant
        $('#secondProcessingData').hide();
        myUploadStarted = true; // force this to true
        textToSay = ``;
        latestData.hide();
      }

      // every second it grabs it from the ether and decrements it and rebuilds the string

      const eitherProcess = processNumber ===  1 || processNumber === 2;
      l({eitherProcess});

      // TODO: need my upload finished? && !myUploadFinished
      if(eitherProcess && myUpload && hitTheBackend && myUploadStarted){
        l('found my data');
        $('#processingData').show();
        // actual process data coming back
        if (Number(percentDone) > 0){
          circleProgress.attr({
            max: 100,
            value: percentDone,
          });
          if (percentDone === 100) {
            $('.progress').hide();
          } else {
            $('.progress').show();
          }


          if(!loopStarted){
            loopStarted = true;

            if(!window.decrementInterval){
              window.decrementInterval = setInterval(function () {
                l('time remaining');
                l(timeRemaining);

                const decrementBySecond = !{decrementBySecond}

                l('decrementing');
                timeRemaining = decrementBySecond(timeRemaining)

                l('time remaining');
                l(timeRemaining);


                const stringToUse = `[${formattedProgressData.percentDone}] ${timeRemaining.string} Remaining, Speed ${formattedProgressData.speed}f/s`

                $('#processingData').html(`${textToSay}${stringToUse}`);
              }, 1000)
            }

            // window.decrementInterval = setInterval(function(){
            //   l('time remaining');
            //   l(timeRemaining);
            //
            //   l('decrementing');
            //   decrementBySecond(timeRemaining)
            //
            //   l('time remaining');
            //   l(timeRemaining);
            //
            //
            //   const stringToUse = `[${formattedProgressData.percentDone}] ${timeRemaining.string} Remaining, Speed ${formattedProgressData.speed}f/s`
            //
            //   $('#processingData').html(`${textToSay}${stringToUse}`);
            // }, 1000)
          }
        } else {
          $('#processingData').html(`${textToSay}Transcription starting soon..`);
        }
      }

      // TODO: this seems off
      // update the process 2 info if appropriate
      if (processNumber === 1 && !myUpload && !myUploadStarted && hitTheBackend) {
        l('getting process 1 data');
        $('#processingData').show();
        $('#processingData').html(`${textToSay}\n${data.processingData}`);
      }
      // update the process 2 info if appropriate
      if (processNumber === 2 && !myUpload && !myUploadStarted && hitTheBackend) {
        l('getting process 2 data');
        $('#secondProcessingData').show();
        $('#secondProcessingData').html(`${textToSay}\n${data.processingData}`);
      }

    } else if (data.message === 'fileDetails') {
      l('file details data');
      const niceDate = new Date().toString().replace(/GMT.*/g,"");
      const niceString = `startedAt: ${niceDate}`;
      $('#finishedData').html(data.fileDetails + niceString);
    } else if (data.message === 'languageUpdate') {
      // Get a reference to the last interval + 1
      const interval_id = window.setInterval(function () {
      }, Number.MAX_SAFE_INTEGER);

      // Clear any timeout/interval up to that id
      for (let i = 1; i < interval_id; i++) {
        window.clearInterval(i);
      }
      $('#processingData').html(data.languageUpdate);

    } else if (data.message === 'error') {
      $('#processingData').html(data.text);
    } else if (data.message === 'starting') {
      latestData.html(data.text);
      $('#processingData').css({'font-size': '1.6rem'});
      $('#processingData').hide();
      $('#secondProcessingData').hide();
      // latestData.css("font-size", "20px");

    } else {
      latestData.html(data);
    }
  };



  /** DRAG AND DROP FILES **/
  body.ondragover = file.ondragenter = function (evt) {
    evt.preventDefault();
  };

  body.ondrop = function (evt) {
    evt.preventDefault();

    // only add the first file
    let list = new DataTransfer();
    let firstPassedFile = evt.dataTransfer.files[0];
    list.items.add(firstPassedFile);

    if(evt?.dataTransfer?.files){
      file.files = list.files;

    } else {
      l('no files found');
    }
  };