const which = require("which");
const spawn = require('child_process').spawn;
const fs = require('fs-extra');
const ffprobe = require('ffprobe');
const WebSocket = require('ws');
var convert = require('cyrillic-to-latin')
const projectConstants = require('./constants');
const { shouldTranslateFrom, languagesToTranscribe, translationLanguages, getLanguageCodeForAllLanguages } = projectConstants;
const forHumans = require('./helpers').forHumans;
const createTranslatedFiles = require('./create-translated-files');
const {formatStdErr} = require("./formatStdErr");

const {
  autoDetectLanguage,
  buildArguments,
  moveAndRenameFilesAndFolder,
  saveTranscriptionCompletedInformation,
} = require('./transcribing');

l = console.log;

const concurrentAmount = process.env.CONCURRENT_AMOUNT;
const nodeEnvironment = process.env.NODE_ENV;
const libreTranslateHostPath = process.env.LIBRETRANSLATE;

l(`libreTranslateHostPath: ${libreTranslateHostPath}`)

const isProd = nodeEnvironment === 'production';

const whisperPath = which.sync('whisper')
const ffprobePath = which.sync('ffprobe')

global.topLevelValue = 1;

async function transcribe({
  uploadedFilePath,
  language,
  model,
  originalFileNameWithExtension,
  originalFileNameWithoutExtension,
  fileSafeNameWithDateTimestamp,
  fileSafeNameWithDateTimestampAndExtension,
  originalFileExtension,
  uploadGeneratedFilename,
  shouldTranslate,
  uploadFileName,
  directorySafeFileNameWithoutExtension,
  originalFileName,
  sixDigitNumber // standin for claimId or something like that
}){
  return new Promise(async (resolve, reject) => {
    try {
      const originalUpload = `./uploads/${uploadFileName}`;

      l('transcribe arguments');
      l(arguments);

      // save date when starting to see how long it's taking
      const startingDate = new Date();
      l(startingDate);

      const whisperProcess = spawn(whisperPath, buildArguments({
        uploadedFilePath: originalUpload, // file to use
        language, //
        model,
        uploadGeneratedFilename: uploadFileName, // name generated by upload
      }));

      // allow you to find the language
      let foundLanguage;

      /**  console output from stdoutt **/
      whisperProcess.stdout.on('data', data => {
        l(`STDOUT: ${data}`)

        // save auto-detected language
        const parsedLanguage = autoDetectLanguage(data.toString());
        if(parsedLanguage) foundLanguage = parsedLanguage;
      });


      /** console output from stderr **/ // (progress comes through stderr for some reason)
      whisperProcess.stderr.on('data', data => {
        l(`STDERR: ${data}`)

        // get value from the whisper output string
        const formattedProgress = formatStdErr(data.toString());
        l('formattedProgress');
        l(formattedProgress);

        const { percentDoneAsNumber, percentDone, speed, timeRemaining  } = formattedProgress;

        // when over 0%, mark as started successfully
        if(percentDoneAsNumber > 0){
          resolve('started')
        }
      });

      /** whisper responds with 0 or 1 process code **/
      whisperProcess.on('close', async (code) => {
        try {
          const processFinishedSuccessfully = code === 0;
          l('code');
          l(code);

          // use auto-detected language
          if(!language){
            language = foundLanguage;
          }

          // successful output
          if(processFinishedSuccessfully){
            // move to the sixDigitNumber directory
            await moveAndRenameFilesAndFolder({
              originalUpload,
              uploadFileName,
              sixDigitNumber,
              originalFileExtension,
            })

            // save processing data with info
            await saveTranscriptionCompletedInformation({
              startingDate,
              sixDigitNumber,
              language,
            })
          } else {
            // process returned with non-0 response
            l('FAILED!');
            reject();
            throw new Error('Transcription has been ended')
          }

          l(`child process exited with code ${code}`);
        } catch (err){
          reject(err);
          l('err here');
          l(err.stack);
          l(err);
          throw new Error(err);
        }
      });
    } catch (err){
      l('error from transcribe')
      l(err);

      reject(err);

      throw new Error(err)
    }

  });

}

module.exports = transcribe;
